from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import HTMLResponse, Response
from sqlalchemy.orm import Session
from sqlalchemy import select, func, and_, or_, extract, text
from sqlalchemy.orm import selectinload
from typing import List, Optional
from datetime import date, datetime, timedelta
from decimal import Decimal
# import pandas as pd  # ìž„ì‹œë¡œ ë¹„í™œì„±í™”

from core.database import get_db
from models.payment import Payment as PaymentModel
from models.customer import Customer as CustomerModel
from models.package import Package as PackageModel, PackagePurchase as PackagePurchaseModel
from schemas.payment import Payment, PaymentCreate
# from utils.receipt import generate_receipt_html, generate_simple_receipt  # ìž„ì‹œë¡œ ë¹„í™œì„±í™”
# from utils.excel import ExcelHandler  # ìž„ì‹œë¡œ ë¹„í™œì„±í™”

router = APIRouter()

@router.post("/", response_model=Payment)
def create_payment(
    payment: PaymentCreate,
    db: Session = Depends(get_db)
):
    """ê²°ì œ ë“±ë¡"""
    # ê³ ê° í™•ì¸
    customer_query = select(CustomerModel).where(CustomerModel.customer_id == payment.customer_id)
    customer_result = db.execute(customer_query)
    customer = customer_result.scalar_one_or_none()
    
    if not customer:
        raise HTTPException(status_code=404, detail="ê³ ê°ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    # ê²°ì œ ìƒì„±
    db_payment = PaymentModel(**payment.model_dump())
    db.add(db_payment)
    
    # íŒ¨í‚¤ì§€ êµ¬ë§¤ ì²˜ë¦¬ (íŒ¨í‚¤ì§€ IDê°€ ì œê³µëœ ê²½ìš°)
    if hasattr(payment, 'package_id') and payment.package_id:
        package_query = select(PackageModel).where(PackageModel.package_id == payment.package_id)
        package_result = db.execute(package_query)
        package = package_result.scalar_one_or_none()
        
        if package:
            # íŒ¨í‚¤ì§€ êµ¬ë§¤ ë ˆì½”ë“œ ìƒì„±
            purchase = PackagePurchaseModel(
                customer_id=payment.customer_id,
                package_id=payment.package_id,
                purchase_date=payment.payment_date,
                expiry_date=payment.payment_date + timedelta(days=package.valid_days),
                total_sessions=package.total_sessions,
                used_sessions=0,
                remaining_sessions=package.total_sessions
            )
            db.add(purchase)
    
    db.commit()
    db.refresh(db_payment)
    
    return db_payment

@router.get("/")
def get_payments(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    customer_id: Optional[int] = None,
    payment_method: Optional[str] = None,
    skip: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """ê²°ì œ ë‚´ì—­ ì¡°íšŒ"""
    try:
        # ë¨¼ì € payments í…Œì´ë¸” ì¡´ìž¬ ì—¬ë¶€ í™•ì¸
        check_table = text("SELECT COUNT(*) as count FROM information_schema.tables WHERE table_name = 'payments'")
        table_result = db.execute(check_table).scalar()
        
        if table_result == 0:
            print("âŒ payments í…Œì´ë¸”ì´ ì¡´ìž¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return []
        
        # payments í…Œì´ë¸” ë°ì´í„° ê°œìˆ˜ í™•ì¸
        count_query = text("SELECT COUNT(*) FROM payments")
        payments_count = db.execute(count_query).scalar()
        print(f"ðŸ“Š payments í…Œì´ë¸”ì— {payments_count}ê°œì˜ ë ˆì½”ë“œê°€ ìžˆìŠµë‹ˆë‹¤.")
        
        if payments_count == 0:
            print("â„¹ï¸ payments í…Œì´ë¸”ì´ ë¹„ì–´ìžˆìŠµë‹ˆë‹¤.")
            return []
        
        # ì‹¤ì œ ì¡´ìž¬í•˜ëŠ” ì»¬ëŸ¼ë§Œ ì¡°íšŒ
        # ë¨¼ì € í…Œì´ë¸” êµ¬ì¡° í™•ì¸
        columns_query = text("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'payments' 
            ORDER BY ordinal_position
        """)
        columns_result = db.execute(columns_query)
        available_columns = [row.column_name for row in columns_result]
        print(f"ðŸ“‹ payments í…Œì´ë¸” ì»¬ëŸ¼: {available_columns}")
        
        # ê¸°ë³¸ ì»¬ëŸ¼ë§Œ ì‚¬ìš©í•œ ì•ˆì „í•œ ì¿¼ë¦¬
        safe_query = text("SELECT payment_id, customer_id, payment_date, amount, payment_method FROM payments LIMIT :limit")
        safe_result = db.execute(safe_query, {"limit": limit})
        
        payments = []
        for row in safe_result:
            payment_dict = {
                "payment_id": row.payment_id,
                "customer_id": row.customer_id,
                "customer_name": "",  # JOIN ì—†ì´ ì¼ë‹¨ ë¹ˆ ê°’
                "customer_phone": "",  # JOIN ì—†ì´ ì¼ë‹¨ ë¹ˆ ê°’
                "payment_date": row.payment_date.isoformat() if row.payment_date else None,
                "amount": float(row.amount) if row.amount else 0.0,
                "payment_method": row.payment_method or "",
                "created_at": None
            }
            payments.append(payment_dict)
        
        print(f"âœ… {len(payments)}ê°œì˜ ê²°ì œ ë‚´ì—­ì„ ë°˜í™˜í•©ë‹ˆë‹¤.")
        return payments
        
    except Exception as e:
        print(f"âŒ ê²°ì œ ì¡°íšŒ ì—ëŸ¬ ìƒì„¸: {str(e)}")
        print(f"ì—ëŸ¬ íƒ€ìž…: {type(e)}")
        import traceback
        traceback.print_exc()
        # ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜í•˜ì—¬ ì„œë²„ê°€ ì£½ì§€ ì•Šë„ë¡
        return []

@router.get("/stats/summary")
def get_payment_summary(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    db: Session = Depends(get_db)
):
    """ê²°ì œ í†µê³„ ìš”ì•½"""
    query = select(
        func.count(PaymentModel.payment_id).label('total_count'),
        func.sum(PaymentModel.amount).label('total_amount'),
        func.count(func.distinct(PaymentModel.customer_id)).label('unique_customers')
    )
    
    if date_from:
        query = query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        query = query.where(PaymentModel.payment_date <= date_to)
    
    result = db.execute(query)
    summary = result.one()
    
    # ê²°ì œ ë°©ë²•ë³„ í†µê³„
    method_query = select(
        PaymentModel.payment_method,
        func.count(PaymentModel.payment_id).label('count'),
        func.sum(PaymentModel.amount).label('amount')
    ).group_by(PaymentModel.payment_method)
    
    if date_from:
        method_query = method_query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        method_query = method_query.where(PaymentModel.payment_date <= date_to)
    
    method_result = db.execute(method_query)
    method_stats = method_result.all()
    
    return {
        "total_count": summary.total_count or 0,
        "total_amount": float(summary.total_amount or 0),
        "unique_customers": summary.unique_customers or 0,
        "by_method": [
            {
                "method": stat.payment_method,
                "count": stat.count,
                "amount": float(stat.amount)
            }
            for stat in method_stats
        ]
    }

@router.get("/stats/daily")
def get_daily_revenue(
    year: int,
    month: int,
    db: Session = Depends(get_db)
):
    """ì¼ë³„ ë§¤ì¶œ í†µê³„"""
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1)
    else:
        end_date = date(year, month + 1, 1)
    
    query = select(
        PaymentModel.payment_date,
        func.count(PaymentModel.payment_id).label('count'),
        func.sum(PaymentModel.amount).label('revenue')
    ).where(
        and_(
            PaymentModel.payment_date >= start_date,
            PaymentModel.payment_date < end_date
        )
    ).group_by(PaymentModel.payment_date).order_by(PaymentModel.payment_date)
    
    result = db.execute(query)
    daily_stats = result.all()
    
    # ì „ì²´ ë‚ ì§œì— ëŒ€í•œ ë°ì´í„° ìƒì„±
    daily_data = {}
    for stat in daily_stats:
        daily_data[stat.payment_date] = {
            "count": stat.count,
            "revenue": float(stat.revenue)
        }
    
    # ë¹ˆ ë‚ ì§œ ì±„ìš°ê¸°
    current = start_date
    result_data = []
    while current < end_date:
        if current in daily_data:
            result_data.append({
                "date": current.isoformat(),
                "count": daily_data[current]["count"],
                "revenue": daily_data[current]["revenue"]
            })
        else:
            result_data.append({
                "date": current.isoformat(),
                "count": 0,
                "revenue": 0
            })
        current += timedelta(days=1)
    
    return result_data

@router.get("/stats/top-customers")
def get_top_customers(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    """ë§¤ì¶œ ìƒìœ„ ê³ ê°"""
    query = select(
        PaymentModel.customer_id,
        CustomerModel.name,
        CustomerModel.phone,
        func.count(PaymentModel.payment_id).label('payment_count'),
        func.sum(PaymentModel.amount).label('total_amount'),
        func.max(PaymentModel.payment_date).label('last_payment_date')
    ).join(
        CustomerModel, PaymentModel.customer_id == CustomerModel.customer_id
    ).group_by(
        PaymentModel.customer_id, CustomerModel.name, CustomerModel.phone
    )
    
    if date_from:
        query = query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        query = query.where(PaymentModel.payment_date <= date_to)
    
    query = query.order_by(func.sum(PaymentModel.amount).desc()).limit(limit)
    
    result = db.execute(query)
    customers = result.all()
    
    return [
        {
            "customer_id": customer.customer_id,
            "name": customer.name,
            "phone": customer.phone,
            "payment_count": customer.payment_count,
            "total_amount": float(customer.total_amount),
            "last_payment_date": customer.last_payment_date.isoformat()
        }
        for customer in customers
    ]

@router.delete("/{payment_id}")
def delete_payment(
    payment_id: int,
    db: Session = Depends(get_db)
):
    """ê²°ì œ ì·¨ì†Œ (ì‚­ì œ)"""
    # ê²°ì œ í™•ì¸
    query = select(PaymentModel).where(PaymentModel.payment_id == payment_id)
    result = db.execute(query)
    payment = result.scalar_one_or_none()
    
    if not payment:
        raise HTTPException(status_code=404, detail="ê²°ì œ ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    # ê´€ë ¨ íŒ¨í‚¤ì§€ êµ¬ë§¤ ë‚´ì—­ë„ í™•ì¸í•˜ê³  ì‚­ì œ í•„ìš” ì‹œ ì²˜ë¦¬
    # (ì‹¤ì œë¡œëŠ” soft deleteë‚˜ ì·¨ì†Œ ìƒíƒœë¡œ ë³€ê²½í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ)
    
    db.delete(payment)
    db.commit()
    
    return {"message": "ê²°ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."}

@router.get("/{payment_id}/receipt")
def get_payment_receipt(
    payment_id: int,
    format: str = Query("html", regex="^(html|text)$"),
    token: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    """ì˜ìˆ˜ì¦ ì¡°íšŒ/ì¶œë ¥"""
    # ê²°ì œ ì •ë³´ ì¡°íšŒ
    query = select(
        PaymentModel,
        CustomerModel
    ).join(
        CustomerModel, PaymentModel.customer_id == CustomerModel.customer_id
    ).where(PaymentModel.payment_id == payment_id)
    
    result = db.execute(query)
    row = result.one_or_none()
    
    if not row:
        raise HTTPException(status_code=404, detail="ê²°ì œ ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    
    payment, customer = row
    
    # ê²°ì œ ë°ì´í„° ì¤€ë¹„ (ê¸°ë³¸ í•„ë“œë§Œ)
    payment_data = {
        "payment_id": payment.payment_id,
        "payment_date": payment.payment_date,
        "amount": float(payment.amount),
        "payment_method": payment.payment_method
    }
    
    customer_data = {
        "name": customer.name,
        "phone": customer.phone,
        "email": customer.email
    }
    
    if format == "html":
        # HTML ì˜ìˆ˜ì¦ ë°˜í™˜
        html_content = generate_receipt_html(payment_data, customer_data)
        return HTMLResponse(content=html_content)
    else:
        # í…ìŠ¤íŠ¸ ì˜ìˆ˜ì¦ ë°˜í™˜
        text_content = generate_simple_receipt(payment_data, customer_data)
        return Response(content=text_content, media_type="text/plain; charset=utf-8")

@router.get("/export/excel")
def export_payments_to_excel(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    customer_id: Optional[int] = None,
    payment_method: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """ê²°ì œ ë°ì´í„°ë¥¼ ì—‘ì…€ íŒŒì¼ë¡œ ë‚´ë³´ë‚´ê¸°"""
    # ê²°ì œ ë‚´ì—­ ì¡°íšŒ
    query = select(
        PaymentModel,
        CustomerModel.name.label('customer_name'),
        CustomerModel.phone.label('customer_phone')
    ).join(
        CustomerModel, PaymentModel.customer_id == CustomerModel.customer_id
    )
    
    # í•„í„°ë§
    if date_from:
        query = query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        query = query.where(PaymentModel.payment_date <= date_to)
    if customer_id:
        query = query.where(PaymentModel.customer_id == customer_id)
    if payment_method:
        query = query.where(PaymentModel.payment_method == payment_method)
    
    # ì •ë ¬
    query = query.order_by(PaymentModel.payment_date.desc(), PaymentModel.payment_id.desc())
    
    result = db.execute(query)
    rows = result.all()
    
    # DataFrame ìƒì„±
    data = []
    for row in rows:
        payment = row[0]
        data.append({
            'ê²°ì œID': payment.payment_id,
            'ê²°ì œì¼': payment.payment_date.strftime('%Y-%m-%d'),
            'ê³ ê°ëª…': row.customer_name,
            'ì „í™”ë²ˆí˜¸': row.customer_phone,
            'ê²°ì œê¸ˆì•¡': float(payment.amount),
            'ê²°ì œë°©ë²•': payment.payment_method
        })
    
    # pandasì™€ ExcelHandlerê°€ ìž„ì‹œ ë¹„í™œì„±í™”ë˜ì–´ ìžˆì–´ì„œ ê°„ë‹¨í•œ ì‘ë‹µìœ¼ë¡œ ëŒ€ì²´
    return {
        "message": "ì—‘ì…€ ë‚´ë³´ë‚´ê¸°ëŠ” ìž„ì‹œ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.",
        "data_count": len(data),
        "data": data[:10]  # ì²˜ìŒ 10ê°œë§Œ ë¯¸ë¦¬ë³´ê¸°
    }