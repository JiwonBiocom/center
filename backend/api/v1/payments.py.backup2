from fastapi import APIRouter, Depends, HTTPException, Query
from fastapi.responses import HTMLResponse, Response
from sqlalchemy.orm import Session
from sqlalchemy import select, func, and_, or_, extract, text
from sqlalchemy.orm import selectinload
from typing import List, Optional
from datetime import date, datetime, timedelta
from decimal import Decimal
# import pandas as pd  # 임시로 비활성화

from core.database import get_db
from models.payment import Payment as PaymentModel
from models.customer import Customer as CustomerModel
from models.package import Package as PackageModel, PackagePurchase as PackagePurchaseModel
from schemas.payment import Payment, PaymentCreate
# from utils.receipt import generate_receipt_html, generate_simple_receipt  # 임시로 비활성화
# from utils.excel import ExcelHandler  # 임시로 비활성화

router = APIRouter()

@router.post("/", response_model=Payment)
def create_payment(
    payment: PaymentCreate,
    db: Session = Depends(get_db)
):
    """결제 등록"""
    # 고객 확인
    customer_query = select(CustomerModel).where(CustomerModel.customer_id == payment.customer_id)
    customer_result = db.execute(customer_query)
    customer = customer_result.scalar_one_or_none()
    
    if not customer:
        raise HTTPException(status_code=404, detail="고객을 찾을 수 없습니다.")
    
    # 결제 생성
    db_payment = PaymentModel(**payment.model_dump())
    db.add(db_payment)
    
    # 패키지 구매 처리 (패키지 ID가 제공된 경우)
    if hasattr(payment, 'package_id') and payment.package_id:
        package_query = select(PackageModel).where(PackageModel.package_id == payment.package_id)
        package_result = db.execute(package_query)
        package = package_result.scalar_one_or_none()
        
        if package:
            # 패키지 구매 레코드 생성
            purchase = PackagePurchaseModel(
                customer_id=payment.customer_id,
                package_id=payment.package_id,
                purchase_date=payment.payment_date,
                expiry_date=payment.payment_date + timedelta(days=package.valid_days),
                total_sessions=package.total_sessions,
                used_sessions=0,
                remaining_sessions=package.total_sessions
            )
            db.add(purchase)
    
    db.commit()
    db.refresh(db_payment)
    
    return db_payment

@router.get("/")
def get_payments(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    customer_id: Optional[int] = None,
    payment_method: Optional[str] = None,
    skip: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """결제 내역 조회"""
    try:
        # 먼저 payments 테이블 존재 여부 확인
        check_table = text("SELECT COUNT(*) as count FROM information_schema.tables WHERE table_name = 'payments'")
        table_result = db.execute(check_table).scalar()
        
        if table_result == 0:
            print("❌ payments 테이블이 존재하지 않습니다.")
            return []
        
        # payments 테이블 데이터 개수 확인
        count_query = text("SELECT COUNT(*) FROM payments")
        payments_count = db.execute(count_query).scalar()
        print(f"📊 payments 테이블에 {payments_count}개의 레코드가 있습니다.")
        
        if payments_count == 0:
            print("ℹ️ payments 테이블이 비어있습니다.")
            return []
        
        # 실제 존재하는 컬럼만 조회
        # 먼저 테이블 구조 확인
        columns_query = text("""
            SELECT column_name 
            FROM information_schema.columns 
            WHERE table_name = 'payments' 
            ORDER BY ordinal_position
        """)
        columns_result = db.execute(columns_query)
        available_columns = [row.column_name for row in columns_result]
        print(f"📋 payments 테이블 컬럼: {available_columns}")
        
        # 기본 컬럼만 사용한 안전한 쿼리
        safe_query = text("SELECT payment_id, customer_id, payment_date, amount, payment_method FROM payments LIMIT :limit")
        safe_result = db.execute(safe_query, {"limit": limit})
        
        payments = []
        for row in safe_result:
            payment_dict = {
                "payment_id": row.payment_id,
                "customer_id": row.customer_id,
                "customer_name": "",  # JOIN 없이 일단 빈 값
                "customer_phone": "",  # JOIN 없이 일단 빈 값
                "payment_date": row.payment_date.isoformat() if row.payment_date else None,
                "amount": float(row.amount) if row.amount else 0.0,
                "payment_method": row.payment_method or "",
                "created_at": None
            }
            payments.append(payment_dict)
        
        print(f"✅ {len(payments)}개의 결제 내역을 반환합니다.")
        return payments
        
    except Exception as e:
        print(f"❌ 결제 조회 에러 상세: {str(e)}")
        print(f"에러 타입: {type(e)}")
        import traceback
        traceback.print_exc()
        # 빈 리스트 반환하여 서버가 죽지 않도록
        return []

@router.get("/stats/summary")
def get_payment_summary(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    db: Session = Depends(get_db)
):
    """결제 통계 요약"""
    query = select(
        func.count(PaymentModel.payment_id).label('total_count'),
        func.sum(PaymentModel.amount).label('total_amount'),
        func.count(func.distinct(PaymentModel.customer_id)).label('unique_customers')
    )
    
    if date_from:
        query = query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        query = query.where(PaymentModel.payment_date <= date_to)
    
    result = db.execute(query)
    summary = result.one()
    
    # 결제 방법별 통계
    method_query = select(
        PaymentModel.payment_method,
        func.count(PaymentModel.payment_id).label('count'),
        func.sum(PaymentModel.amount).label('amount')
    ).group_by(PaymentModel.payment_method)
    
    if date_from:
        method_query = method_query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        method_query = method_query.where(PaymentModel.payment_date <= date_to)
    
    method_result = db.execute(method_query)
    method_stats = method_result.all()
    
    return {
        "total_count": summary.total_count or 0,
        "total_amount": float(summary.total_amount or 0),
        "unique_customers": summary.unique_customers or 0,
        "by_method": [
            {
                "method": stat.payment_method,
                "count": stat.count,
                "amount": float(stat.amount)
            }
            for stat in method_stats
        ]
    }

@router.get("/stats/daily")
def get_daily_revenue(
    year: int,
    month: int,
    db: Session = Depends(get_db)
):
    """일별 매출 통계"""
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1)
    else:
        end_date = date(year, month + 1, 1)
    
    query = select(
        PaymentModel.payment_date,
        func.count(PaymentModel.payment_id).label('count'),
        func.sum(PaymentModel.amount).label('revenue')
    ).where(
        and_(
            PaymentModel.payment_date >= start_date,
            PaymentModel.payment_date < end_date
        )
    ).group_by(PaymentModel.payment_date).order_by(PaymentModel.payment_date)
    
    result = db.execute(query)
    daily_stats = result.all()
    
    # 전체 날짜에 대한 데이터 생성
    daily_data = {}
    for stat in daily_stats:
        daily_data[stat.payment_date] = {
            "count": stat.count,
            "revenue": float(stat.revenue)
        }
    
    # 빈 날짜 채우기
    current = start_date
    result_data = []
    while current < end_date:
        if current in daily_data:
            result_data.append({
                "date": current.isoformat(),
                "count": daily_data[current]["count"],
                "revenue": daily_data[current]["revenue"]
            })
        else:
            result_data.append({
                "date": current.isoformat(),
                "count": 0,
                "revenue": 0
            })
        current += timedelta(days=1)
    
    return result_data

@router.get("/stats/top-customers")
def get_top_customers(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    limit: int = Query(10, ge=1, le=50),
    db: Session = Depends(get_db)
):
    """매출 상위 고객"""
    query = select(
        PaymentModel.customer_id,
        CustomerModel.name,
        CustomerModel.phone,
        func.count(PaymentModel.payment_id).label('payment_count'),
        func.sum(PaymentModel.amount).label('total_amount'),
        func.max(PaymentModel.payment_date).label('last_payment_date')
    ).join(
        CustomerModel, PaymentModel.customer_id == CustomerModel.customer_id
    ).group_by(
        PaymentModel.customer_id, CustomerModel.name, CustomerModel.phone
    )
    
    if date_from:
        query = query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        query = query.where(PaymentModel.payment_date <= date_to)
    
    query = query.order_by(func.sum(PaymentModel.amount).desc()).limit(limit)
    
    result = db.execute(query)
    customers = result.all()
    
    return [
        {
            "customer_id": customer.customer_id,
            "name": customer.name,
            "phone": customer.phone,
            "payment_count": customer.payment_count,
            "total_amount": float(customer.total_amount),
            "last_payment_date": customer.last_payment_date.isoformat()
        }
        for customer in customers
    ]

@router.delete("/{payment_id}")
def delete_payment(
    payment_id: int,
    db: Session = Depends(get_db)
):
    """결제 취소 (삭제)"""
    # 결제 확인
    query = select(PaymentModel).where(PaymentModel.payment_id == payment_id)
    result = db.execute(query)
    payment = result.scalar_one_or_none()
    
    if not payment:
        raise HTTPException(status_code=404, detail="결제 내역을 찾을 수 없습니다.")
    
    # 관련 패키지 구매 내역도 확인하고 삭제 필요 시 처리
    # (실제로는 soft delete나 취소 상태로 변경하는 것이 좋음)
    
    db.delete(payment)
    db.commit()
    
    return {"message": "결제가 취소되었습니다."}

@router.get("/{payment_id}/receipt")
def get_payment_receipt(
    payment_id: int,
    format: str = Query("html", regex="^(html|text)$"),
    token: Optional[str] = Query(None),
    db: Session = Depends(get_db)
):
    """영수증 조회/출력"""
    # 결제 정보 조회
    query = select(
        PaymentModel,
        CustomerModel
    ).join(
        CustomerModel, PaymentModel.customer_id == CustomerModel.customer_id
    ).where(PaymentModel.payment_id == payment_id)
    
    result = db.execute(query)
    row = result.one_or_none()
    
    if not row:
        raise HTTPException(status_code=404, detail="결제 내역을 찾을 수 없습니다.")
    
    payment, customer = row
    
    # 결제 데이터 준비 (기본 필드만)
    payment_data = {
        "payment_id": payment.payment_id,
        "payment_date": payment.payment_date,
        "amount": float(payment.amount),
        "payment_method": payment.payment_method
    }
    
    customer_data = {
        "name": customer.name,
        "phone": customer.phone,
        "email": customer.email
    }
    
    if format == "html":
        # HTML 영수증 반환
        html_content = generate_receipt_html(payment_data, customer_data)
        return HTMLResponse(content=html_content)
    else:
        # 텍스트 영수증 반환
        text_content = generate_simple_receipt(payment_data, customer_data)
        return Response(content=text_content, media_type="text/plain; charset=utf-8")

@router.get("/export/excel")
def export_payments_to_excel(
    date_from: Optional[date] = Query(None),
    date_to: Optional[date] = Query(None),
    customer_id: Optional[int] = None,
    payment_method: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """결제 데이터를 엑셀 파일로 내보내기"""
    # 결제 내역 조회
    query = select(
        PaymentModel,
        CustomerModel.name.label('customer_name'),
        CustomerModel.phone.label('customer_phone')
    ).join(
        CustomerModel, PaymentModel.customer_id == CustomerModel.customer_id
    )
    
    # 필터링
    if date_from:
        query = query.where(PaymentModel.payment_date >= date_from)
    if date_to:
        query = query.where(PaymentModel.payment_date <= date_to)
    if customer_id:
        query = query.where(PaymentModel.customer_id == customer_id)
    if payment_method:
        query = query.where(PaymentModel.payment_method == payment_method)
    
    # 정렬
    query = query.order_by(PaymentModel.payment_date.desc(), PaymentModel.payment_id.desc())
    
    result = db.execute(query)
    rows = result.all()
    
    # DataFrame 생성
    data = []
    for row in rows:
        payment = row[0]
        data.append({
            '결제ID': payment.payment_id,
            '결제일': payment.payment_date.strftime('%Y-%m-%d'),
            '고객명': row.customer_name,
            '전화번호': row.customer_phone,
            '결제금액': float(payment.amount),
            '결제방법': payment.payment_method
        })
    
    # pandas와 ExcelHandler가 임시 비활성화되어 있어서 간단한 응답으로 대체
    return {
        "message": "엑셀 내보내기는 임시 비활성화되었습니다.",
        "data_count": len(data),
        "data": data[:10]  # 처음 10개만 미리보기
    }